\section{Umsetzung}

\subsection{Einrichtung}
\paragraph{}
Es wurde der zur Entwicklung im Tagesgeschäft bei Check24 bereitgestellte Laptop
für das Projekt genutzt auf dem bereits ein Linux-Betriebssystem installiert war.
Auch die genutzte \gls{IDE} war bereits aufgrund anderer Projekte vorinstalliert.
Lediglich die \LaTeX-Entwicklungsumgebung und Details der Build-Umgebung mussten
speziell für dieses Projekt konfiguriert werden.

\paragraph{}
Zu diesem Zweck wurde über das Betriebssystem \TeX-Live \cite{texlive} installiert
und ein Plugin für die \gls{IDE} \cite{latex-workshop}. Die Buildumgebung
wurde so konfiguriert, dass bei jedem Speichern einer Datei das Programm kompiliert wird,
sämtliche Softwaretests ausgeführt werden, sowohl die Moduldokumentation als auch
der Graph der Modulabhängigkeiten neu generiert wird und Tools zur Formatierung
und statischen Codeanalyse ausgeführt werden.

\subsection{Entwicklung}
TODO

\subsection{Dokumentation}
Das Projekt wurde sowohl auf Quellcodeebene zum Zwecke der Weiterentwicklung als
auch für Nutzer bzw. Kunden dokumentiert (siehe Kapitel \ref{Kundendokumentation} - Kundendokumentation).

\paragraph{Code- und Moduldokumentation}
Jedes Modul und jede Deklaration im Code ist mit Codekommentaren versehen wie in
den Abbildungen \ref{codecomment-module} und \ref{codecomment-declaration} darstellt.
Anhand dieser Informationen wird mittels Haddock \cite{haddock}, während des Buildprozesses,
eine navigierbare und übersichtliche Moduldokumentation im HTML-Format erstellt,
die sowohl die Module des Programms selbst als auch die der verwendeten Softwarebibiliotheken
beschreibt und im Projektverzeichnis unter \mintinline{bash}{/doc/generated}
abgelegt ist.

\begin{figure}
    \caption{Beispiel eines Modul-Codekommentars}
    \label{codecomment-module}
    \begin{minted}[bgcolor=codebg]{haskell}
-- Module      : FileSynchronization
-- Description : Expose a function which, for a given config
--   item, will read the corresponding file and determine the
--   current value as it would be identified by the pattern.
-- Copyright   : (c) Adrian Schurz, 2022
-- License     : MIT
-- Maintainer  : adrian.schurz@check24.com
-- Stability   : experimental
...
    \end{minted}
\end{figure}

\begin{figure}
    \caption{Beispiel eines Deklarations-Codekommentars}
    \label{codecomment-declaration}
    \begin{minted}[bgcolor=codebg]{haskell}
-- | A function to change the cursor position to point at the
--   next item.
selectNextItem :: AppState -> AppState
...
    \end{minted}
\end{figure}

\paragraph{Projektdokumentation}
Die Dokumentation der Projektarbeit selbst erfolgt mittels \LaTeX \cite{latex} und
wird im \gls{PDF}-Format exportiert. Alle Quelldateien für dieses Dokument sind
ebenfalls im Projektverzeichnis unter \mintinline{bash}{/doc/azubi-project/projektdokumentation}
auffindbar.

\subsection{Qualitätssicherung}
Zur Qualitätssicherung dienten hauptsächlich Unittests, inklusive \gls{Property-Based-Testing},
und händische Tests.

\paragraph{Unittests}
Ein Beispiel für einen Unittest ist in Abb. \ref{unit-test} gegeben. Damit wird
pro Test die Ausgabe einer Funktion für einen speziellen Eingabewert mit einem
korrekten Ausgabewert verglichen. Diese Art des Testens einzelner Codesegmente ist
sinnvoll, aber aufgrund der beschränkten menschlichen Kreativität nicht besonders
gut geeignet um Grenzfälle mit besonders großen, besonders absurden oder anderweitig
unerwarteten Eingabewerten zu ausfindig zu machen.

\begin{figure}
    \caption{Beispiel eines Unittests, aus Platzgründen mit ... eingekürzt und inklusive
        der Ausgabe bei Ausführung (unterhalb des Pfeils)}
    \label{unit-test}
    \begin{minted}[bgcolor=codebg]{text}
describe "changing the element at a certain index inside of a list" $ do
  it "given a valid index ... apply it at the appropriate index" $
    let someList = [1, 2, 3]
        someFunction = (*) 2
        validIndex = 1
    in changeNthElement validIndex ... someList `shouldBe` [1, 4, 3]

                                ↓

changing the element at a certain index inside of a list
    given a valid index ... apply it at the appropriate index [✔]
    \end{minted}
\end{figure}

\paragraph{\gls{Property-Based-Testing}}
Um die obengenannte Schwäche von reinen Unittests auszugleichen wurden zusätzlich
sogenannte Propertytests verfasst, welche mit einer großen Anzahl von zufällig generierten
Eingabewerten bestimmte Eigenschaften der Ausgabewerte prüfen. In Abb. \ref{property-test}
ist ein Test illustriert, der sicherstellt, dass die Zieldatei, unabhängig von
sowohl ihrem Inhalt als auch dem konfigurierten \gls{Zielmuster}, unverändert
bleibt wannimmer der aktuelle Wert und der neue Zielwert identisch sind. Zu
jeder Ausführung der Testsuite werden dafür eine große Anzahl zufälliger Dateiinhalte
und Zielmuster generiert und die Funktion damit geprüft.

\begin{figure}
    \caption{Beispiel für \gls{Property-Based-Testing}, aus Platzgründen mit ... eingekürzt und inklusive
        der Ausgabe bei Ausführung einer großen Anzahl automatisch generierter Tests (unterhalb des Pfeils)}
    \label{property-test}
    \begin{minted}[bgcolor=codebg]{text}
describe "modifying a string according to a search pattern ..." $ do
    prop "... old and new values are identical ... content unchanged" $
        \tva pat cont -> modify tva tva pat cont == cont

                                ↓

modifying a string according to a search pattern ...
    given that the old and new values are ... content unchanged [✔]
        +++ OK, passed 1000 tests.
    \end{minted}
\end{figure}

\paragraph{Akzeptanztests}
Bestimmte Klassen von Softwarefehlern lassen sich allein mit Unittests nicht
zuverlässig auschließen. Für die umfänglichste Überprüfung der Software sind
Tests, welche die Ausführung des kompilierten Programms, inklusiver simulierter
Nutzerinteraktion, prüfen, von hohem Wert. Es wurde versucht mit Mitteln des
Unittesting in Bash \cite{bats} , virtualisierten Betriebssystemen \cite{virtualbox} \cite{docker}
bzw. \gls{Terminalemulator}en und Tools zur Emulation von Tastatureingaben \cite{xdotool} \cite{ydotool}
solche Test zu realisieren. Das Ergebnis ist in Kapitel
\ref{Testabdeckung} - Testabdeckung dokumentiert. Akzeptanztests, welche nicht
automatisiert durchgeführt werden konnten, wurden regelmäßig händische Tests des
kompilierten Programms auf dem Entwicklungsrechner durchgeführt. Ab einem
gewissen Zeitpunkt während der Entwicklung befand sich das Programm bereits in einem nutzbaren
Zustand. Es wurde vom Entwickler selbst von da an produktiv eingesetzt was,
ähnlich dem Konzept des \gls{Betatesting}s, eine praktisch wertvolle, wenn auch wenig rigorose,
Testabdeckung ermöglicht hat.